第15讲
- - -

### 提纲
#### 处理机调度概念
- 进程切换：CPU资源的当前占用者切换，保存当前进程在PCB的执行上下文（CPU状态），恢复下一个进程的执行上下文
- 处理机调度：从就绪队列中挑选出下一个占用CPU运行的进程
- 对多处理机，要从多个可用CPU中挑选就绪进程可使用的CPU资源
- 调度程序：挑选就绪进程的内核函数
- 调度策略：依据什么选下一个进程
- 调度时机：什么时候进行调度

#### 调度时机
- 内核运行调度程序的条件：
	- 进程从运行状态到等待状态
	- 进程终结
- 非抢占系统：当前进程主动放弃CPU时
- 抢占系统：
	- 中断请求被服务例程相应完成时
	- 当前进程被抢占：1.时间片用完。2.进程从等待状态到就绪状态

### 调度准则
- 调度策略：如何从就绪队列中选择下一个执行进程
- 比较调度算法的准则
	- CPU使用率：CPU处于忙状态时的时间百分比
	- 吞吐量：单位时间内完成的进程数量
	- 周转时间：进程从初始化到结束（包括等待）的琮时间
	- 等待时间：进程在就绪队列中的总时间
	- 相应时间：从提交请求到产生相应所花费的总时间
- 处理机的使用模式：
	- 进程在CPU计算和IO操作间交替（此时CPU通常处于等待状态），通常CPU执行时间很短，IO时间很长
	- 每次调度决定下一个CPU计算时将哪个工作交给CPU
	- 在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU，所以时间片单位要合适
- 调度算法的要求：希望“更快”的服务
	- 传输文件时的高带宽，调度算法的高吞吐量
	- 玩游戏时的低延迟，调度算法的低响应延迟
	- 这两个因素是独立的
- 与水管的类比：
	- 低延迟：想喝水的时候打开水龙头水就流出来
	- 高带宽：给游泳池冲水时希望水龙头里流出大量水

#### 处理机调度策略的目标
- 处理机调度的响应时间目标：
	- 减少响应时间：及时处理用户的输入请求
	- 减少平均响应时间的波动：在交互系统中，可预测性比高差异低平均更重要
	- 低延迟调度改善了用户的交互体验
	- 响应时间是操作系统的计算延迟
- 处理机调度的吞吐量目标
	- 增加吞吐量：减少开销，系统资源的高效利用
	- 减少等待时间：减少每个进程的等待时间
	- 操作系统需要保护吞吐量不受用户交互的影响（操作系统必须不时进行调度，即使存在许多交互任务）
	- 吞吐量是操作系统的计算带宽
- 处理机调度的公平性目标：
	- 保证每个进程占用相同的CPU时间
	- 保证每个进程的等待时间相同
	- 不同场合对公平性的度量不同

### 调度算法
#### 先来先服务算法：FCFS
- 依据进程进入就绪状态的先后顺序排毒
	- 进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU
	- 周转时间=sigma（各进程结束时刻）/进程数
	- 周转时间跟队列到达时间有很大关系
- 优点
	- 简单
- 缺点
	- 平均等待时间波动非常大：短进程可能排在长进程后面
	- IO资源和CPU资源的利用率比较低：CPU密集型进程会导致IO设备闲置时，IO密集型进程也等待
	
#### 短进程优先算法：SPN，SJF，SRT
- SPN：选择就绪队列中执行时间最短进程占用CPU进入运行状态
	- 就绪队列按预期的执行时间来排序
	- 如果新进程预期时间比当前正在执行的还短怎么办？
- SRT：短剩余时间优先算法
	- SPN算法的可抢占改进
	- 最优平均周转时间
	- 若正在执行的进程剩余时间比就绪队列中的最短执行时间长，那么可以进行抢占
	- 可能导致饥饿：连续的短进程流会导致长进程无法获得CPU资源
	- 需要预知未来：如何预估下一个CPU计算的持续时间？
	- 简单的解决方法：询问用户。用户欺骗就杀死相应程序。用户不知道怎么办？
	- 用历史的执行时间来预估未来的执行时间
	- tao_(n+1) = a*t_n+(1-a)*tao_n, 0<=a<=1
	- t_n:第n次的CPU计算时间
	- tao_(n+1):第n+1次CPU计算时间预估
	- tao_(n+1)=a*t_n+(1-a)*a*t_(n-1)+(1-a)*(1-a)*a*t_(n-2)

#### 最高相应比有限算法：HRRN
- 选择就绪队列中相应比R值最高的进程
	- R=(w+s)/s
	- w：等待时间，s：执行时间
- 在短进程优先算法基础上的改进
- 不可抢占
- 关注进程的等待时间
- 防止无限期推迟

#### 时间片轮转算法：RR
- 时间片：分配处理机资源的基本时间单元
- 算法思路：
	- 时间片结束时，按FCFS算法切换到下一个就绪队列
	- 每隔n-1各时间片进程执行下一个时间片q
- 算法开销：额外的上下文切换
- 时间片太大：等待时间过长，极限情况下退化成FCFS
- 时间片太小：反应迅速，单产生大量上下文切换，影响到系统吞吐量
- 时间片长度选择目标：选择一个合适的时间片长度，根据经验使上下文切换开销处于1%以内

#### 多级反馈队列算法：MFQ
##### 多级队列调度算法MQ
- 就绪队列被划分成多个独立的子队列，如：前台（交互），后台（批处理）
- 每个队列可以有自己的调度策略
- 队列间调度：
	- 固定优先级
	- 先处理前台，后处理后台
	- 可能导致饥饿
- 时间片轮转：
	- 每隔队列得到一个确定的能够调度其进程的CPU时间，例如80%前台，20%后台

##### 多级反馈队列算法MLFQ
- 进程可在不同队列间移动的多级队列算法
	- 时间片大小随优先级级别增加而增加
	- 入进程在当前时间片没有完成，则降到下一个优先级
- 特征：
	- CPU密集型进程的优先级下降很快
	- IO密集型进程停留在高优先级

#### 公平共享调度算法：FSS
- FSS控制用户对系统资源的访问
	- 一些用户组比其它用户组重要，保证不重要的组无法垄断资源

#### 传统调度算法总结
- 先来先服务算法FCFS
	- 不公平，平均等待时间较差
- 短进程优先算法SPN
	- 不公平，平均周转时间最小
	- 需要精确预测计算时间
	- 可能导致饥饿
- 最高相应比优先算法HRRN
	- 基于SPN调度
	- 不可抢占
- 时间片轮转算法RR
	- 公平，但是平均等待时间较差
- 多级反馈队列MFQ
	- 多种算法的继承
	- 实际系统
- 公平共享调度FSS
	- 公平是第一要素

#### ucore的调度框架
- run_queue
- ucore的线程状态：runnable和sleeping
- uninit到runnable的函数：proc_init
- runnable到sleeping的函数：try_free_pages,do_wait,do_sleep
- sleeping到runnable的函数：wakeup_proc
- runnable到zombie的函数：do_exit
- ucore的调度时机：在发生系统调用、异常、中断时，处理完trap后添加schedule函数，从而进行调度（在保存trapframe和恢复trapframe中间，同理返回时也是返回到这里，继续执行恢复trapframe，返回用户态）。调度时机就是在返回用户态之前
- 调度算法接口sched_class

### 实时调度
- 实时操作系统：正确性依赖与时间和功能两方面的操作系统
- 性能指标：时间约束的及时性，速度和平均性能相对不重要
- 特性：时间约束的可预测性
- 实时任务：一次计算，一次文件读取等
- 任务属性：完成任务所需要的资源，定时参数
- 周期实时任务：一系列相似的任务
	- 任务有规律的重复
	- 周期p=任务请求时间间隔（p>0）
	- 执行时间e=最大执行时间（0<e<p）
	- 使用率U=e/p
- 硬时限：
	- 错过任务时限会导致灾难性或非常严重的后果
	- 必须验证，在最坏情况下能满足时限
- 软时限
	- 通常能满足任务时限，如果不能满足，则降低要求
	- 尽力保证满足任务时限
- 可调度性：	
	- 一个实时操作系统能够满足任务时限要求
	- 需要确定实时任务的执行顺序
	- 静态优先级调度
	- 动态优先级调度
- 速率单调调度算法RM（Rate Monotonic）（静态）
	- 通过周期安排优先级
	- 周期越短优先级越高
	- 执行周期最短的任务
- 最早截止时间优先算法（EDF，Earliest Deadline First）（动态）
	- 截止时间越早优先级越高
	- 执行截止时间最早的任务

### 多处理机调度
- 特征：
	- 多处理机组成一个多处理机系统
	- 处理机间可负载共享
- 对称多处理机（SMP）调度
	- 每个处理器运行自己的调度程序
	- 调度程序对共享资源的访问需要进行同步
- 进程分配
- 静态进程分配
	- 进程从开始到结束都被分配到一个固定的处理机上执行
	- 每隔处理机有自己的就绪队列
	- 调度开销小
	- 各处理机可能忙闲不均
- 动态进程分配
	- 进程在执行中可分配到任意空闲处理机执行
	- 所有处理机共享一个公共的就绪队列
	- 调度开销大
	- 各处理机的负载是均衡的

### 优先级反置
#### 问题
- 操作系统中高优先级的进程由于等待低优先级进程占用的资源而导致高优先级进程长期等待的现象。
- 基于优先级的可抢占调度算法存在优先级反置
#### 解决方法
- 优先级继承
	- 占用资源的低优先级进程继承申请资源的高优先级进程的优先级
	- 只在占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级
- 优先级天花板协议
	- 占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同
	- 不管是否发生等待，都提升占用资源进程的优先级
	- 
